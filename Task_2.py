# -*- coding: utf-8 -*-
"""Day 2 workshop(NLP).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OM7kWlz1WE0iJy33V-2hr7BCqRlUvK_B

# **Data analysis and cleaning**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

car = pd.read_csv('/content/cardekho_dataset.csv')

car.shape

car.describe()

car.head()

car.isnull().sum()

car = car.drop(['Unnamed: 0', 'model', 'seller_type'], axis=1)

car.head()

car['car_name'].value_counts()

car=car.drop('car_name', axis=1)

car['fuel_type'].value_counts()

car['transmission_type'].value_counts()

car = car.drop('brand',axis=1)

car['fuel_type'] = car['fuel_type'].astype('category').cat.codes

car['transmission_type'] = car['transmission_type'].astype('category').cat.codes

car.head()

plt.figure(figsize=(4,3))
plt.scatter(car['mileage'], car['km_driven'], marker='*', c = 'r', alpha=0.8)
plt.xlabel('Mileage')
plt.ylabel('km_driven')
plt.title('Mileage vs Kms Driven')
plt.legend(['Efficiency'])
plt.grid(True)
plt.show()

trans_count = car['transmission_type'].value_counts()

trans_count.plot(kind = 'bar', figsize=(7,6), color = 'red')
plt.show()

salary = pd.read_csv('/content/salary_data.csv')

salary.shape

salary.describe()

salary.isnull().sum()

plt.figure(figsize=(8, 6))
plt.scatter(salary['YearsExperience'], salary['Salary'], c=['gold'], marker='^')
plt.xlabel('Years of Experience')
plt.ylabel('Salary')
plt.title('Salary vs. Years of Experience')
plt.grid(True)
plt.show()

from sklearn.linear_model import LinearRegression

x = salary['YearsExperience'].values.reshape(-1,1)
y = salary['Salary']

from sklearn.model_selection import train_test_split

xtrain, xtest, ytrain, ytest = train_test_split(x,y, test_size=0.3, random_state=20)

xtrain

ytrain

#model building
from sklearn.linear_model import LinearRegression

salary = LinearRegression()
salary

salary.fit(xtrain, ytrain)

pred = salary.predict(xtest)
pred

ytest

from sklearn.metrics import mean_squared_error

mse = mean_squared_error(ytest, pred)
mse

import numpy as np

rmse = np.sqrt(mse)
rmse

"""# **Logistic Regression**"""

diabetes = pd.read_csv('/content/diabetes.csv')

diabetes.head()

diabetes.isnull().sum()

X = diabetes.drop('Outcome',axis=1)
Y = diabetes['Outcome']

X

#feature scaling or normalization[where we do avg=0 and std. variance=1]
from sklearn.preprocessing import StandardScaler

scalar = StandardScaler()

Xtrain, Xtest, Ytrain, Ytest = train_test_split(X, Y, test_size=0.2, random_state=57)

#feature scaling
Xtrain_scaled = scalar.fit_transform(Xtrain)
Xtest_scaled = scalar.transform(Xtest)

from sklearn.linear_model import LogisticRegression

DB = LogisticRegression()
DB

DB.fit(Xtrain_scaled, Ytrain)

Ypred = DB.predict(Xtest_scaled)
Ypred

Ytest

from sklearn.metrics import accuracy_score

ac = accuracy_score(Ytest, Ypred)
ac

"""# **Classification Models**

**1. KNN - (Lazy algorithm)It identifies nearer obj, which is more in number among 2, it will move to the obj which is large in number--building a model where it can classify acc to variety of seeds**
"""

seed = pd.read_excel('/content/seed_dataset.xlsx')

seed.info()

seed.isnull().sum()

seed['Class'].value_counts()

seed['Class'] = seed['Class'].astype('category').cat.codes

seed.head()

seed = seed.drop('Perimeter', axis=1)

f = seed.drop('Class', axis=1)
t = seed['Class']

from sklearn.neighbors import KNeighborsClassifier

SEED = KNeighborsClassifier(n_neighbors=8)
SEED

f_train, f_test, t_train, t_test = train_test_split(f, t, test_size=0.2, random_state=78)
SEED.fit(f_train, t_train)
pred = SEED.predict(f_test)

scalar = StandardScaler()

f_train_scaled = scalar.fit_transform(f_train)
f_test_scaled = scalar.transform(f_test)
f_test_scaled = scalar.transform(f_test)

accuracy = accuracy_score(t_test, pred)
print(f"Accuracy of KNN model: {accuracy}")

"""# **Decision Tree Classifier**"""

weather = pd.read_csv('/content/seattle-weather.csv')

weather.info()

weather.head()

weather.isnull().sum()

weather['temp_avg'] = (weather['temp_max'] + weather['temp_min']) / 2

weather.head()

weather.describe()

weather = weather.drop(['date', 'temp_max', 'temp_min'], axis=1)

weather.head()

weather['weather'].value_counts()

weather['weather'] = weather['weather'].astype('category').cat.codes

from sklearn.tree import DecisionTreeClassifier

f_train, f_test, t_train, t_test = train_test_split(f, t, test_size=0.2, random_state=78)

scalar = StandardScaler()

f_train_scaled = scalar.fit_transform(f_train)
f_test_scaled = scalar.transform(f_test)
f_test_scaled = scalar.transform(f_test)

dt_classifier = DecisionTreeClassifier(random_state=42)
dt_classifier.fit(f_train, t_train)

y_pred = dt_classifier.predict(f_test)

accuracy = accuracy_score(t_test, y_pred)
print(f"Accuracy of the Decision Tree Classifier: {accuracy}")

"""# **Applying Gradio for decision tree alg**"""

!pip install gradio

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
import gradio as gr

# Load and preprocess data
weather = pd.read_csv('/content/seattle-weather.csv')
weather['temp_avg'] = (weather['temp_max'] + weather['temp_min']) / 2
weather = weather.drop(['date', 'temp_max', 'temp_min'], axis=1)
weather['weather'] = weather['weather'].astype('category')
weather_labels = dict(enumerate(weather['weather'].cat.categories))  # To decode later
weather['weather'] = weather['weather'].cat.codes

# Features and target
f = weather.drop('weather', axis=1)
t = weather['weather']

# Train-test split
f_train, f_test, t_train, t_test = train_test_split(f, t, test_size=0.2, random_state=78)

# Scaling
scalar = StandardScaler()
f_train_scaled = scalar.fit_transform(f_train)
f_test_scaled = scalar.transform(f_test)

# Train model
dt_classifier = DecisionTreeClassifier(random_state=42)
dt_classifier.fit(f_train_scaled, t_train)

# Accuracy
y_pred = dt_classifier.predict(f_test_scaled)
accuracy = accuracy_score(t_test, y_pred)
print(f"Accuracy of the Decision Tree Classifier: {accuracy}")

# Gradio function
def predict_weather(precipitation, wind, temp_avg):
    input_data = pd.DataFrame([[precipitation, wind, temp_avg]], columns=['precipitation', 'wind', 'temp_avg'])
    input_scaled = scalar.transform(input_data)
    prediction_code = dt_classifier.predict(input_scaled)[0]
    predicted_weather = weather_labels[prediction_code]
    return f"Predicted Weather Condition: {predicted_weather}"

# Gradio interface
interface = gr.Interface(
    fn=predict_weather,
    inputs=[
        gr.Number(label="Precipitation (inches)"),
        gr.Number(label="Wind Speed (mph)"),
        gr.Number(label="Average Temperature (¬∞F)")
    ],
    outputs=gr.Textbox(label="Predicted Weather"),
    title="üå§Ô∏è Seattle Weather Predictor",
    description=f"Enter weather values to predict the condition using Decision Tree (Accuracy: {round(accuracy*100, 2)}%)"
)

interface.launch()

